<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Twilio Call Diagnostic</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    button { padding: 10px 20px; font-size: 16px; margin: 10px 0; }
    pre { background: #f5f5f5; padding: 10px; border-radius: 6px; overflow-x: auto; }
    .ok { color: green; }
    .fail { color: red; }
    .info { color: #555; }
  </style>
</head>
<body>
  <h2>WebRTC Diagnostic (Twilio-compatible)</h2>
  <button id="runTest">Run Diagnostic</button>
  <div id="output"></div>

  <script>
    const output = document.getElementById("output");

    function log(msg, type = "info") {
      const div = document.createElement("div");
      div.className = type;
      div.textContent = msg;
      output.appendChild(div);
    }

    async function checkMediaDevices() {
      log("Checking for media devices...");
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioIn = devices.filter(d => d.kind === "audioinput");
        const videoIn = devices.filter(d => d.kind === "videoinput");

        if (audioIn.length > 0) log(`✅ Found ${audioIn.length} microphone(s)`, "ok");
        else log("❌ No microphone found", "fail");

        if (videoIn.length > 0) log(`✅ Found ${videoIn.length} camera(s)`, "ok");
        else log("❌ No camera found", "fail");
      } catch (err) {
        log("❌ Could not enumerate devices: " + err.message, "fail");
      }
    }

    async function checkPermissions() {
      log("Requesting camera and microphone access...");
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        log("✅ Camera and microphone accessible", "ok");
        stream.getTracks().forEach(t => t.stop());
      } catch (err) {
        log("❌ Cannot access camera/microphone: " + err.message, "fail");
      }
    }

    async function testICE() {
      log("Running ICE connectivity test with STUN/TURN...");
      return new Promise(async (resolve) => {
        try {
          const pc = new RTCPeerConnection({
            iceServers: [
              { urls: "stun:global.stun.twilio.com:3478" },
              { urls: "stun:stun.l.google.com:19302" },
              // {
              //   urls: "turn:global.turn.twilio.com:3478",
              //   username: "your_twilio_username",
              //   credential: "your_twilio_credential"
              // }
            ]
          });

          pc.createDataChannel("test"); // triggers ICE

          pc.onicecandidate = (event) => {
            if (event.candidate) {
              console.dir(event);
              log(`ICE candidate: ${event.candidate.type} via ${event.candidate.protocol} (${event.candidate.address}:${event.candidate.candidate})`);
            }
          };

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          setTimeout(() => {
            pc.close();
            log("✅ ICE test finished", "ok");
            resolve();
          }, 5000);
        } catch (err) {
          log("❌ ICE test failed: " + err.message, "fail");
          resolve();
        }
      });
    }

    async function testCallQuality(durationMs = 5000) {
      log("Running bandwidth & call quality test...");

      return new Promise(async (resolve) => {
        let pc1, pc2, localStream;
        try {
          pc1 = new RTCPeerConnection();
          pc2 = new RTCPeerConnection();

          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
          localStream.getTracks().forEach(track => pc1.addTrack(track, localStream));

          pc1.onicecandidate = e => e.candidate && pc2.addIceCandidate(e.candidate);
          pc2.onicecandidate = e => e.candidate && pc1.addIceCandidate(e.candidate);

          pc2.ontrack = e => {
            // We receive remote media here (ignored, loopback only)
          };

          const offer = await pc1.createOffer();
          await pc1.setLocalDescription(offer);
          await pc2.setRemoteDescription(offer);

          const answer = await pc2.createAnswer();
          await pc2.setLocalDescription(answer);
          await pc1.setRemoteDescription(answer);

          // Collect stats for a few seconds
          const statsResults = [];
          const start = Date.now();

          const collect = async () => {
            const stats = await pc1.getStats(null);
            stats.forEach(report => {
              if (report.type === "outbound-rtp" && !report.isRemote) {
                statsResults.push({
                  timestamp: report.timestamp,
                  bitrate: report.bytesSent,
                  packetsSent: report.packetsSent,
                  packetsLost: report.packetsLost || 0,
                  jitter: report.jitter || 0,
                  roundTripTime: report.roundTripTime || 0
                });
              }
            });
          };

          const interval = setInterval(collect, 1000);

          setTimeout(async () => {
            clearInterval(interval);
            await collect();

            if (statsResults.length > 1) {
              const first = statsResults[0];
              const last = statsResults[statsResults.length - 1];
              const bytesSent = last.bitrate - first.bitrate;
              const bitrateKbps = (bytesSent * 8) / ((last.timestamp - first.timestamp) / 1000) / 1000;

              log(`✅ Estimated upload bitrate: ${bitrateKbps.toFixed(1)} kbps`, "ok");
              log(`ℹ️ Packets sent: ${last.packetsSent}, lost: ${last.packetsLost}`, "info");
              log(`ℹ️ Jitter: ${last.jitter}`, "info");
              log(`ℹ️ RTT: ${last.roundTripTime}`, "info");
            } else {
              log("❌ Not enough stats collected", "fail");
            }

            localStream.getTracks().forEach(t => t.stop());
            pc1.close();
            pc2.close();
            resolve();
          }, durationMs);
        } catch (err) {
          log("❌ Quality test failed: " + err.message, "fail");
          if (localStream) localStream.getTracks().forEach(t => t.stop());
          if (pc1) pc1.close();
          if (pc2) pc2.close();
          resolve();
        }
      });
    }

    async function runDiagnostic() {
      output.innerHTML = "";
      await checkMediaDevices();
      await checkPermissions();
      await testICE();
      await testCallQuality();
      log("✅ Diagnostic finished", "ok");
    }

    document.getElementById("runTest").onclick = () => {
      runDiagnostic().catch(err => {
        log("❌ Fatal error: " + err.message, "fail");
      });
    };
  </script>
</body>
</html>
